<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Finn & Perry's Words</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: 'Segoe UI', 'Comic Sans MS', Arial, sans-serif;
    color: #fff;
    min-height: 100vh;
    overflow-x: hidden;
    transition: background .8s;
  }
  body.theme-space { background: #0b0e2d; }
  body.theme-dino { background: #1a3a1a; }
  body.theme-ocean { background: #0a2a4a; }
  body.theme-jungle { background: #1a3a0a; }
  body.theme-arctic { background: #c8dff0; }

  /* ---- backgrounds ---- */
  .bg-layer { position: fixed; inset: 0; pointer-events: none; z-index: 0; transition: opacity .8s; opacity: 0; }
  .bg-layer.active { opacity: 1; }

  .bg-space { background: radial-gradient(ellipse at 50% 0%, #1a1f5e 0%, #0b0e2d 70%); }
  .bg-dino { background: linear-gradient(180deg, #2d5a1e 0%, #3a7a2a 40%, #5a4a2a 70%, #3d2b1f 100%); }
  .bg-ocean { background: linear-gradient(180deg, #0a4a8a 0%, #0a2a5a 40%, #0a1a3a 100%); }
  .bg-jungle { background: linear-gradient(180deg, #4a8a2a 0%, #2a6a1a 30%, #1a4a0a 60%, #0a2a00 100%); }
  .bg-arctic { background: linear-gradient(180deg, #a0c8e8 0%, #c8dff0 30%, #e0eef8 60%, #f0f5fa 100%); }

  .stars { position: fixed; inset: 0; pointer-events: none; z-index: 0; }
  .stars span {
    position: absolute; border-radius: 50%; background: #fff;
    animation: twinkle var(--d, 3s) ease-in-out infinite alternate;
  }
  @keyframes twinkle { 0% { opacity: .2; transform: scale(.8); } 100% { opacity: 1; transform: scale(1.2); } }

  /* ocean bubbles bg */
  .ocean-bgs { position: fixed; inset: 0; pointer-events: none; z-index: 0; }
  .ocean-bgs .bg-bubble {
    position: absolute; border-radius: 50%; border: 2px solid rgba(255,255,255,.15);
    animation: floatUp var(--d, 8s) linear infinite;
    opacity: .3;
  }
  @keyframes floatUp { 0% { transform: translateY(0); opacity: .3; } 100% { transform: translateY(-110vh); opacity: 0; } }

  /* dino bg elements */
  .dino-bgs { position: fixed; inset: 0; pointer-events: none; z-index: 0; }

  .screen { display: none; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; position: relative; z-index: 1; padding: 20px; }
  .screen.active { display: flex; }

  /* ---- SETUP ---- */
  #setup-screen h1 { font-size: clamp(2rem, 6vw, 3.5rem); margin-bottom: 8px; color: #ffd166; text-shadow: 0 0 20px rgba(255,209,102,.6); }
  #setup-screen p { font-size: clamp(1rem, 3vw, 1.4rem); margin-bottom: 24px; color: #a0c4ff; }
  #setup-screen .emoji-row { font-size: clamp(2.5rem, 7vw, 4rem); margin-bottom: 12px; }

  textarea {
    width: min(90vw, 420px); height: 180px;
    border: 3px solid #5e60ce; border-radius: 16px;
    background: #1b1f4b; color: #fff;
    font-size: clamp(1.1rem, 3vw, 1.4rem);
    padding: 16px; resize: vertical; outline: none;
  }
  textarea::placeholder { color: #7e80b0; }
  textarea:focus { border-color: #ffd166; box-shadow: 0 0 15px rgba(255,209,102,.3); }

  .btn {
    margin-top: 20px; padding: 16px 48px;
    font-size: clamp(1.3rem, 4vw, 1.8rem); font-weight: 700;
    border: none; border-radius: 50px; cursor: pointer;
    background: linear-gradient(135deg, #f72585, #7209b7);
    color: #fff; text-shadow: 0 2px 4px rgba(0,0,0,.3);
    box-shadow: 0 6px 20px rgba(247,37,133,.4);
    transition: transform .15s, box-shadow .15s;
  }
  .btn:hover { transform: scale(1.05); box-shadow: 0 8px 28px rgba(247,37,133,.5); }
  .btn:active { transform: scale(.97); }

  .error-msg { color: #ff6b6b; margin-top: 10px; font-size: 1.1rem; min-height: 1.4em; }

  /* ---- GAME ---- */
  #game-screen { justify-content: flex-start; padding-top: 16px; gap: 8px; }

  .game-top-bar {
    width: 100%; max-width: 700px;
    display: flex; justify-content: space-between; align-items: center;
    font-size: clamp(.9rem, 2.5vw, 1.1rem); color: #a0c4ff;
  }

  .theme-icon {
    position: fixed; top: 12px; right: 12px; z-index: 10;
    font-size: 2rem; background: rgba(0,0,0,.3); border-radius: 50%;
    width: 48px; height: 48px; display: flex; align-items: center; justify-content: center;
    transition: transform .3s;
  }
  .theme-icon:hover { transform: scale(1.15); }

  .animation-container {
    width: min(90vw, 360px); height: min(55vw, 240px);
    position: relative; margin: 4px 0;
  }
  .animation-container canvas { width: 100%; height: 100%; }

  .guesses-left {
    font-size: clamp(1rem, 3vw, 1.3rem); color: #ffd166; margin-bottom: 2px;
  }

  .word-display {
    display: flex; gap: clamp(6px, 2vw, 14px);
    margin: 8px 0; flex-wrap: wrap; justify-content: center;
  }
  .word-display .letter-slot {
    width: clamp(32px, 8vw, 52px); height: clamp(40px, 10vw, 60px);
    border-bottom: 4px solid #5e60ce;
    display: flex; align-items: center; justify-content: center;
    font-size: clamp(1.5rem, 5vw, 2.4rem); font-weight: 700;
    color: #fff; text-transform: uppercase; transition: color .3s;
  }
  .word-display .letter-slot.revealed { color: #06d6a0; border-color: #06d6a0; }

  .keyboard {
    display: flex; flex-wrap: wrap; justify-content: center;
    gap: clamp(4px, 1vw, 8px);
    max-width: 700px; margin-top: 8px;
  }
  .key-btn {
    width: clamp(34px, 8vw, 52px); height: clamp(38px, 9vw, 54px);
    border: 2px solid #5e60ce; border-radius: 12px;
    background: #1b1f4b; color: #fff;
    font-size: clamp(1rem, 3vw, 1.5rem); font-weight: 700;
    cursor: pointer; transition: all .15s; text-transform: uppercase;
    display: flex; align-items: center; justify-content: center;
  }
  .key-btn:hover:not(:disabled) { background: #5e60ce; transform: scale(1.08); }
  .key-btn:disabled { opacity: .25; cursor: default; transform: none; }
  .key-btn.correct { background: #06d6a0; border-color: #06d6a0; color: #0b0e2d; }
  .key-btn.wrong { background: #ef476f; border-color: #ef476f; }

  /* ---- RESULT OVERLAY ---- */
  .result-overlay {
    display: none; position: fixed; inset: 0; z-index: 100;
    background: rgba(11,14,45,.92);
    flex-direction: column; align-items: center; justify-content: center;
    padding: 20px; text-align: center;
  }
  .result-overlay.active { display: flex; }
  .result-overlay h2 { font-size: clamp(2rem, 7vw, 3.5rem); margin-bottom: 12px; }
  .result-overlay p { font-size: clamp(1.1rem, 3.5vw, 1.6rem); margin-bottom: 8px; color: #a0c4ff; }
  .result-overlay .word-reveal { font-size: clamp(1.4rem, 4vw, 2rem); color: #ffd166; margin-bottom: 20px; }

  /* ---- THEME TRANSITION ---- */
  .theme-transition {
    display: none; position: fixed; inset: 0; z-index: 200;
    align-items: center; justify-content: center;
    flex-direction: column; background: rgba(0,0,0,.85);
  }
  .theme-transition.active { display: flex; }
  .theme-transition .tt-emoji { font-size: 5rem; animation: ttBounce .6s ease-in-out infinite alternate; }
  .theme-transition .tt-text { font-size: 1.8rem; color: #ffd166; margin-top: 16px; font-weight: 700; }
  @keyframes ttBounce { 0% { transform: scale(1) translateY(0); } 100% { transform: scale(1.2) translateY(-10px); } }

  /* ---- SUMMARY ---- */
  #summary-screen h2 { font-size: clamp(1.8rem, 5vw, 3rem); color: #ffd166; margin-bottom: 16px; }
  #summary-screen .score { font-size: clamp(3rem, 10vw, 5rem); color: #06d6a0; font-weight: 700; }
  #summary-screen .score-label { font-size: clamp(1.1rem, 3vw, 1.5rem); color: #a0c4ff; margin-bottom: 12px; }
  .word-results { list-style: none; margin-bottom: 24px; max-height: 35vh; overflow-y: auto; width: min(90vw, 400px); }
  .word-results li {
    display: flex; justify-content: space-between; align-items: center;
    padding: 10px 16px; font-size: clamp(1rem, 3vw, 1.3rem);
    border-bottom: 1px solid #2a2d5e; text-transform: uppercase;
  }
  .word-results .mark { font-size: 1.3em; }

  /* ---- celebration particles ---- */
  .celebration { position: fixed; inset: 0; pointer-events: none; z-index: 150; }
  .celebration .particle {
    position: absolute; border-radius: 50%;
    animation: pop var(--dur) ease-out forwards;
  }
  @keyframes pop {
    0% { opacity: 1; transform: translate(0,0) scale(1); }
    100% { opacity: 0; transform: translate(var(--tx), var(--ty)) scale(0); }
  }
</style>
</head>
<body class="theme-space">

<!-- Background layers -->
<div class="bg-layer bg-space active" id="bg-space"></div>
<div class="bg-layer bg-dino" id="bg-dino"></div>
<div class="bg-layer bg-ocean" id="bg-ocean"></div>
<div class="bg-layer bg-jungle" id="bg-jungle"></div>
<div class="bg-layer bg-arctic" id="bg-arctic"></div>
<div class="stars" id="stars"></div>
<div class="ocean-bgs" id="ocean-bgs" style="display:none"></div>

<!-- Theme icon -->
<div class="theme-icon" id="theme-icon" style="display:none"></div>

<!-- Theme transition overlay -->
<div class="theme-transition" id="theme-transition">
  <div class="tt-emoji" id="tt-emoji"></div>
  <div class="tt-text" id="tt-text"></div>
</div>

<!-- SETUP SCREEN -->
<div class="screen active" id="setup-screen">
  <div class="emoji-row" aria-hidden="true">&#x1F680; &#x1F95A; &#x1F420; &#x1F435; &#x1F427;</div>
  <h1>Finn &amp; Perry's Words</h1>
  <p>Type your spelling words below (one per line)</p>
  <textarea id="word-input" placeholder="cat&#10;dog&#10;sun&#10;moon"></textarea>
  <div class="error-msg" id="setup-error"></div>
  <button class="btn" id="launch-btn">Let's Go!</button>
</div>

<!-- GAME SCREEN -->
<div class="screen" id="game-screen">
  <div class="game-top-bar">
    <span id="progress-label">Word 1 / 1</span>
    <span id="score-label">Score: 0</span>
  </div>
  <div class="animation-container"><canvas id="game-canvas"></canvas></div>
  <div class="guesses-left" id="guesses-left">6 guesses left</div>
  <div class="word-display" id="word-display"></div>
  <div class="keyboard" id="keyboard"></div>
</div>

<!-- WIN / LOSE OVERLAY -->
<div class="result-overlay" id="result-overlay">
  <h2 id="result-title"></h2>
  <p id="result-msg"></p>
  <div class="word-reveal" id="result-word"></div>
  <button class="btn" id="next-btn">Next Word</button>
</div>

<!-- SUMMARY SCREEN -->
<div class="screen" id="summary-screen">
  <h2>All Done!</h2>
  <div class="score" id="final-score"></div>
  <div class="score-label" id="final-label"></div>
  <ul class="word-results" id="word-results"></ul>
  <button class="btn" id="restart-btn">Play Again</button>
</div>

<!-- Celebration container -->
<div class="celebration" id="celebration"></div>

<script>
// ========== AUDIO ==========
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let actx;
function ensureAudio() { if (!actx) actx = new AudioCtx(); }
function playTone(freq, dur, type, vol) {
  try {
    ensureAudio();
    const o = actx.createOscillator(), g = actx.createGain();
    o.type = type || 'sine'; o.frequency.value = freq;
    g.gain.value = vol || .15;
    g.gain.exponentialRampToValueAtTime(.001, actx.currentTime + dur);
    o.connect(g); g.connect(actx.destination);
    o.start(); o.stop(actx.currentTime + dur);
  } catch(e) {}
}
function sfxCorrect() { playTone(523,.12,'sine',.18); setTimeout(()=>playTone(659,.12,'sine',.18),100); setTimeout(()=>playTone(784,.2,'sine',.18),200); }
function sfxWrong()   { playTone(200,.3,'sawtooth',.1); }
function sfxWin()     { [523,659,784,1047].forEach((f,i)=>setTimeout(()=>playTone(f,.18,'sine',.16),i*120)); }
function sfxLose()    { [400,350,300,250].forEach((f,i)=>setTimeout(()=>playTone(f,.22,'triangle',.12),i*180)); }

// ========== STARS ==========
(function makeStars(){
  const c = document.getElementById('stars');
  for(let i=0;i<80;i++){
    const s = document.createElement('span');
    const sz = Math.random()*3+1;
    Object.assign(s.style,{
      width: sz+'px', height: sz+'px',
      left: Math.random()*100+'%', top: Math.random()*100+'%',
      '--d': (Math.random()*3+2)+'s'
    });
    c.appendChild(s);
  }
})();

// ========== OCEAN BUBBLES BG ==========
function makeOceanBg() {
  const c = document.getElementById('ocean-bgs');
  c.innerHTML = '';
  for (let i = 0; i < 15; i++) {
    const b = document.createElement('div');
    b.className = 'bg-bubble';
    const sz = Math.random() * 20 + 8;
    Object.assign(b.style, {
      width: sz + 'px', height: sz + 'px',
      left: Math.random() * 100 + '%', top: (80 + Math.random() * 30) + '%',
      '--d': (Math.random() * 8 + 6) + 's',
      animationDelay: (Math.random() * 8) + 's'
    });
    c.appendChild(b);
  }
}

// ========== THEMES ==========
const THEMES = ['space', 'dino', 'ocean', 'jungle', 'arctic'];
const THEME_EMOJIS = { space: '&#x1F680;', dino: '&#x1F95A;', ocean: '&#x1F420;', jungle: '&#x1F435;', arctic: '&#x1F427;' };
const THEME_NAMES = { space: 'Space Theme', dino: 'Dino Theme', ocean: 'Ocean Theme', jungle: 'Jungle Theme', arctic: 'Arctic Theme' };
const THEME_LOSE_MSG = {
  space: "Oh no, the alien flew away! Let's try the next word!",
  dino: "The dino escaped! Can you catch the next word?",
  ocean: "The fish swam away! Let's try the next word!",
  jungle: "The monkey swung away! Let's try the next word!",
  arctic: "The penguin is hiding! Let's try the next word!"
};
let currentTheme = 'space';
let lastTheme = null;

function pickTheme() {
  const t = THEMES[Math.floor(Math.random() * THEMES.length)];
  return t;
}

function applyTheme(theme) {
  lastTheme = currentTheme;
  currentTheme = theme;
  document.body.className = 'theme-' + theme;
  document.querySelectorAll('.bg-layer').forEach(l => l.classList.remove('active'));
  document.getElementById('bg-' + theme).classList.add('active');
  const icon = document.getElementById('theme-icon');
  icon.innerHTML = THEME_EMOJIS[theme] || '&#x1F3AE;';
  icon.style.display = 'flex';
  // stars visibility
  document.getElementById('stars').style.display = theme === 'space' ? '' : 'none';
  // ocean bg
  const ob = document.getElementById('ocean-bgs');
  if (theme === 'ocean') { ob.style.display = ''; makeOceanBg(); } else { ob.style.display = 'none'; }
}

function showThemeTransition(theme, cb) {
  const overlay = document.getElementById('theme-transition');
  document.getElementById('tt-emoji').innerHTML = THEME_EMOJIS[theme] || '&#x1F3AE;';
  document.getElementById('tt-text').textContent = THEME_NAMES[theme] + '!';
  overlay.classList.add('active');
  applyTheme(theme);
  setTimeout(() => {
    overlay.classList.remove('active');
    if (cb) cb();
  }, 1200);
}

// ========== STATE ==========
let words=[], wordIdx=0, currentWord='', guessed=new Set(), wrongCount=0, score=0, results=[], gameOver=false;
const MAX_WRONG = 6;
let animFrame = 0; // for end animations

// ========== DOM ==========
const $=id=>document.getElementById(id);
const screens = ['setup-screen','game-screen','summary-screen'];
function showScreen(id){ screens.forEach(s=>$(s).classList.toggle('active', s===id)); }

// ========== SETUP ==========
$('launch-btn').addEventListener('click', ()=>{
  const raw = $('word-input').value.trim();
  if(!raw){ $('setup-error').textContent='Please type at least one word!'; return; }
  words = raw.split(/\n+/).map(w=>w.trim().toLowerCase().replace(/[^a-z]/g,'')).filter(Boolean);
  if(!words.length){ $('setup-error').textContent='No valid words found!'; return; }
  $('setup-error').textContent='';
  wordIdx=0; score=0; results=[];
  const theme = pickTheme();
  showThemeTransition(theme, ()=> startRound());
});

// ========== GAME ROUND ==========
function startRound(){
  currentWord = words[wordIdx];
  guessed = new Set(); wrongCount = 0; gameOver = false; animFrame = 0;
  // Give one random letter as a hint
  const uniqueLetters = [...new Set(currentWord)];
  const hintLetter = uniqueLetters[Math.floor(Math.random() * uniqueLetters.length)];
  guessed.add(hintLetter);
  showScreen('game-screen');
  $('result-overlay').classList.remove('active');
  $('progress-label').textContent = `Word ${wordIdx+1} / ${words.length}`;
  $('score-label').textContent = `Score: ${score}`;
  renderWord();
  renderKeyboard();
  updateGuessesLeft();
  drawCanvas();
}

function renderWord(){
  const d = $('word-display'); d.innerHTML='';
  for(const ch of currentWord){
    const s = document.createElement('div');
    s.className = 'letter-slot';
    if(guessed.has(ch)){ s.textContent = ch; s.classList.add('revealed'); }
    else { s.textContent = '\u00A0'; }
    d.appendChild(s);
  }
}

function renderKeyboard(){
  const k = $('keyboard'); k.innerHTML='';
  for(let i=0;i<26;i++){
    const ch = String.fromCharCode(97+i);
    const b = document.createElement('button');
    b.className='key-btn'; b.textContent=ch; b.dataset.letter=ch;
    if(guessed.has(ch)){
      b.disabled=true;
      b.classList.add(currentWord.includes(ch)?'correct':'wrong');
    }
    b.addEventListener('click', ()=>guess(ch));
    k.appendChild(b);
  }
}

function guess(ch){
  if(gameOver||guessed.has(ch)) return;
  ensureAudio();
  guessed.add(ch);
  if(currentWord.includes(ch)){ sfxCorrect(); } else { wrongCount++; sfxWrong(); }
  renderWord(); renderKeyboard(); updateGuessesLeft(); drawCanvas();
  checkEnd();
}

function updateGuessesLeft(){
  const left = MAX_WRONG - wrongCount;
  $('guesses-left').textContent = left === 1 ? '1 guess left!' : `${left} guesses left`;
  $('guesses-left').style.color = left<=2 ? '#ef476f' : '#ffd166';
}

function checkEnd(){
  const won = [...currentWord].every(c=>guessed.has(c));
  const lost = wrongCount >= MAX_WRONG;
  if(!won && !lost) return;
  gameOver = true;
  results.push({word:currentWord, won});
  if(won) score++;
  if (won) {
    setTimeout(()=> runWinAnimation(), 300);
  } else {
    setTimeout(()=> runLoseAnimation(), 400);
  }
}

// ========== END ANIMATIONS ==========
let endAnimId = null;
function runWinAnimation() {
  sfxWin();
  animFrame = 0;
  const duration = 1500;
  const start = performance.now();
  function tick(now) {
    animFrame = Math.min((now - start) / duration, 1);
    drawCanvas();
    if (animFrame < 1) { endAnimId = requestAnimationFrame(tick); }
    else { spawnCelebration(); setTimeout(()=> showResult(true), 500); }
  }
  endAnimId = requestAnimationFrame(tick);
}

function runLoseAnimation() {
  sfxLose();
  animFrame = 0;
  const duration = 1800;
  const start = performance.now();
  function tick(now) {
    animFrame = Math.min((now - start) / duration, 1);
    drawCanvas();
    if (animFrame < 1) { endAnimId = requestAnimationFrame(tick); }
    else { setTimeout(()=> showResult(false), 300); }
  }
  endAnimId = requestAnimationFrame(tick);
}

function showResult(won){
  if (endAnimId) { cancelAnimationFrame(endAnimId); endAnimId = null; }
  const o = $('result-overlay');
  if(won){
    $('result-title').textContent='Great Job! \u2B50';
    $('result-title').style.color='#06d6a0';
    $('result-msg').textContent='You guessed the word!';
    spawnCelebration();
  } else {
    $('result-title').textContent='Oh no!';
    $('result-title').style.color='#ef476f';
    $('result-msg').textContent = THEME_LOSE_MSG[currentTheme];
  }
  $('result-word').textContent = `The word was: ${currentWord.toUpperCase()}`;
  $('next-btn').textContent = wordIdx < words.length-1 ? 'Next Word' : 'See Results';
  o.classList.add('active');
}

$('next-btn').addEventListener('click', ()=>{
  wordIdx++;
  if(wordIdx < words.length){
    const theme = pickTheme();
    if (theme !== currentTheme) {
      $('result-overlay').classList.remove('active');
      showThemeTransition(theme, ()=> startRound());
    } else {
      startRound();
    }
  } else { showSummary(); }
});

// ========== SUMMARY ==========
function showSummary(){
  $('result-overlay').classList.remove('active');
  $('theme-icon').style.display = 'none';
  showScreen('summary-screen');
  $('final-score').textContent = `${score} / ${words.length}`;
  $('final-label').textContent = score===words.length ? 'Perfect score \u2014 amazing!' : score >= words.length/2 ? 'Great work!' : 'Keep practicing, you can do it!';
  const ul = $('word-results'); ul.innerHTML='';
  results.forEach(r=>{
    const li=document.createElement('li');
    li.innerHTML=`<span>${r.word}</span><span class="mark">${r.won?'\u2B50':'\u274C'}</span>`;
    ul.appendChild(li);
  });
  if(score===words.length) spawnCelebration();
}

$('restart-btn').addEventListener('click', ()=>{
  $('theme-icon').style.display = 'none';
  showScreen('setup-screen');
  applyTheme('space');
});

// ========== KEYBOARD INPUT ==========
document.addEventListener('keydown', e=>{
  if($('game-screen').classList.contains('active') && !gameOver){
    const ch = e.key.toLowerCase();
    if(/^[a-z]$/.test(ch)) guess(ch);
  }
});

// ========== CANVAS DRAWING ==========
function getCanvas() {
  const canvas = $('game-canvas');
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.parentElement.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);
  return { ctx, W: rect.width, H: rect.height };
}

function drawCanvas() {
  if (currentTheme === 'space') drawSpace();
  else if (currentTheme === 'dino') drawDino();
  else if (currentTheme === 'ocean') drawOcean();
  else if (currentTheme === 'jungle') drawJungle();
  else if (currentTheme === 'arctic') drawArctic();
}

// ============== SPACE THEME ==============
function drawSpace() {
  const { ctx, W, H } = getCanvas();
  ctx.clearRect(0, 0, W, H);
  const cx = W * .5, groundY = H * .92;

  // ground
  ctx.strokeStyle = '#5e60ce'; ctx.lineWidth = 3; ctx.lineCap = 'round';
  ctx.beginPath(); ctx.moveTo(W * .1, groundY); ctx.lineTo(W * .9, groundY); ctx.stroke();

  // small stars
  ctx.fillStyle = 'rgba(255,255,255,.15)';
  [[.15,.12,2],[.8,.08,1.5],[.6,.18,1.8],[.25,.3,1.2],[.85,.35,1.6]].forEach(([x,y,r])=>{
    ctx.beginPath(); ctx.arc(W*x,H*y,r,0,Math.PI*2); ctx.fill();
  });

  // Alien always visible
  const alienX = W * .2, alienY = groundY - H * .12;
  drawAlien(ctx, alienX, alienY, H);

  // Rocket parts based on wrong guesses (skip if lose animation is playing)
  const rocketX = cx + W * .1, rocketBaseY = groundY;
  const rocketFlying = gameOver && animFrame > 0 && wrongCount >= MAX_WRONG;
  if (!rocketFlying) {
    if (wrongCount >= 1) drawRocketBody(ctx, rocketX, rocketBaseY, H);
    if (wrongCount >= 2) drawRocketWindow(ctx, rocketX, rocketBaseY, H);
    if (wrongCount >= 3) drawRocketFins(ctx, rocketX, rocketBaseY, H);
    if (wrongCount >= 4) drawRocketNose(ctx, rocketX, rocketBaseY, H);
    if (wrongCount >= 5) drawRocketFlame(ctx, rocketX, rocketBaseY, H);
    if (wrongCount >= 6) drawRocketSmoke(ctx, rocketX, rocketBaseY, H);
  }

  // Win animation: stars and confetti around alien
  if (gameOver && animFrame > 0 && wrongCount < MAX_WRONG) {
    drawSpaceWin(ctx, alienX, alienY, W, H);
  }
  // Lose animation: alien goes into rocket, rocket blasts off
  if (rocketFlying) {
    drawSpaceLose(ctx, rocketX, rocketBaseY, alienX, alienY, W, H);
  }
}

function drawAlien(ctx, x, y, H) {
  if (gameOver && animFrame > 0 && wrongCount >= MAX_WRONG) return; // alien is in rocket
  const sz = H * .08;
  // body
  ctx.fillStyle = '#06d6a0';
  ctx.beginPath();
  ctx.ellipse(x, y, sz * .6, sz, 0, 0, Math.PI * 2);
  ctx.fill();
  // head
  ctx.beginPath();
  ctx.arc(x, y - sz * 1.1, sz * .55, 0, Math.PI * 2);
  ctx.fill();
  // eyes
  ctx.fillStyle = '#0b0e2d';
  ctx.beginPath(); ctx.ellipse(x - sz * .2, y - sz * 1.15, sz * .12, sz * .18, 0, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(x + sz * .2, y - sz * 1.15, sz * .12, sz * .18, 0, 0, Math.PI * 2); ctx.fill();
  // eye shine
  ctx.fillStyle = '#fff';
  ctx.beginPath(); ctx.arc(x - sz * .15, y - sz * 1.2, sz * .04, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(x + sz * .25, y - sz * 1.2, sz * .04, 0, Math.PI * 2); ctx.fill();
  // smile
  ctx.strokeStyle = '#0b0e2d'; ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.arc(x, y - sz * 1.0, sz * .2, 0.1 * Math.PI, 0.9 * Math.PI); ctx.stroke();
  // antenna
  ctx.strokeStyle = '#06d6a0'; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(x, y - sz * 1.65); ctx.lineTo(x, y - sz * 1.9); ctx.stroke();
  ctx.fillStyle = '#ffd166';
  ctx.beginPath(); ctx.arc(x, y - sz * 1.95, sz * .1, 0, Math.PI * 2); ctx.fill();
}

function drawRocketBody(ctx, x, y, H) {
  const rw = H * .12, rh = H * .35;
  ctx.fillStyle = '#e0e0e0';
  ctx.strokeStyle = '#999';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.roundRect(x - rw/2, y - rh, rw, rh, [0, 0, 8, 8]);
  ctx.fill(); ctx.stroke();
  // stripe
  ctx.fillStyle = '#ef476f';
  ctx.fillRect(x - rw/2, y - rh * .5, rw, rh * .12);
}

function drawRocketWindow(ctx, x, y, H) {
  const rh = H * .35;
  ctx.fillStyle = '#a0c4ff';
  ctx.strokeStyle = '#5e60ce';
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.arc(x, y - rh * .65, H * .04, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
  // shine
  ctx.fillStyle = 'rgba(255,255,255,.4)';
  ctx.beginPath(); ctx.arc(x - H * .01, y - rh * .67, H * .015, 0, Math.PI * 2); ctx.fill();
}

function drawRocketFins(ctx, x, y, H) {
  const rw = H * .12, rh = H * .35;
  ctx.fillStyle = '#f72585';
  // left fin
  ctx.beginPath();
  ctx.moveTo(x - rw/2, y);
  ctx.lineTo(x - rw/2 - H * .05, y + H * .02);
  ctx.lineTo(x - rw/2, y - rh * .25);
  ctx.closePath(); ctx.fill();
  // right fin
  ctx.beginPath();
  ctx.moveTo(x + rw/2, y);
  ctx.lineTo(x + rw/2 + H * .05, y + H * .02);
  ctx.lineTo(x + rw/2, y - rh * .25);
  ctx.closePath(); ctx.fill();
}

function drawRocketNose(ctx, x, y, H) {
  const rw = H * .12, rh = H * .35;
  ctx.fillStyle = '#ef476f';
  ctx.beginPath();
  ctx.moveTo(x, y - rh - H * .08);
  ctx.lineTo(x - rw/2, y - rh);
  ctx.lineTo(x + rw/2, y - rh);
  ctx.closePath(); ctx.fill();
}

function drawRocketFlame(ctx, x, y, H) {
  // flame
  const flicker = Math.sin(Date.now() / 100) * 3;
  ctx.fillStyle = '#ffd166';
  ctx.beginPath();
  ctx.moveTo(x - H * .04, y);
  ctx.quadraticCurveTo(x, y + H * .1 + flicker, x + H * .04, y);
  ctx.fill();
  ctx.fillStyle = '#ff6b3a';
  ctx.beginPath();
  ctx.moveTo(x - H * .02, y);
  ctx.quadraticCurveTo(x, y + H * .07 + flicker, x + H * .02, y);
  ctx.fill();
}

function drawRocketSmoke(ctx, x, y, H) {
  ctx.fillStyle = 'rgba(200,200,200,.3)';
  for (let i = 0; i < 5; i++) {
    const sx = x + (Math.sin(i * 2 + Date.now()/300) * H * .08);
    const sy = y + H * .05 + i * H * .03;
    const sr = H * .02 + i * H * .01;
    ctx.beginPath(); ctx.arc(sx, sy, sr, 0, Math.PI * 2); ctx.fill();
  }
}

function drawSpaceWin(ctx, ax, ay, W, H) {
  // alien celebrates - bouncing + stars around
  const bounce = Math.sin(animFrame * Math.PI * 4) * 8;
  const sz = H * .08;
  ctx.save();
  ctx.translate(0, bounce);
  // re-draw alien shifted (clear would be complex, just draw on top)
  ctx.restore();

  // stars and sparkles
  const sparkleColors = ['#ffd166', '#f72585', '#06d6a0', '#a0c4ff'];
  for (let i = 0; i < 8; i++) {
    const angle = (i / 8) * Math.PI * 2 + animFrame * Math.PI * 2;
    const dist = H * .15 * animFrame;
    const sx = ax + Math.cos(angle) * dist;
    const sy = ay - sz + Math.sin(angle) * dist;
    ctx.fillStyle = sparkleColors[i % sparkleColors.length];
    ctx.globalAlpha = 1 - animFrame * .5;
    drawStar(ctx, sx, sy, 4, H * .02, H * .01);
    ctx.globalAlpha = 1;
  }
}

function drawSpaceLose(ctx, rx, ry, ax, ay, W, H) {
  const rh = H * .35;
  // rocket flies up
  const liftoff = animFrame * H * 1.2;
  ctx.save();
  ctx.translate(0, -liftoff);

  // redraw rocket
  drawRocketBody(ctx, rx, ry, H);
  drawRocketWindow(ctx, rx, ry, H);
  drawRocketFins(ctx, rx, ry, H);
  drawRocketNose(ctx, rx, ry, H);

  // bigger flame during liftoff
  const flicker = Math.sin(Date.now() / 60) * 5;
  ctx.fillStyle = '#ffd166';
  ctx.beginPath();
  ctx.moveTo(rx - H * .05, ry);
  ctx.quadraticCurveTo(rx, ry + H * .18 + flicker, rx + H * .05, ry);
  ctx.fill();
  ctx.fillStyle = '#ff6b3a';
  ctx.beginPath();
  ctx.moveTo(rx - H * .03, ry);
  ctx.quadraticCurveTo(rx, ry + H * .12 + flicker, rx + H * .03, ry);
  ctx.fill();

  // alien waving from window area (tiny)
  const alienInRocketY = ry - rh * .65;
  ctx.fillStyle = '#06d6a0';
  ctx.beginPath(); ctx.arc(rx, alienInRocketY, H * .025, 0, Math.PI * 2); ctx.fill();
  // tiny eyes
  ctx.fillStyle = '#0b0e2d';
  ctx.beginPath(); ctx.arc(rx - H*.008, alienInRocketY - H*.005, H*.005, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(rx + H*.008, alienInRocketY - H*.005, H*.005, 0, Math.PI*2); ctx.fill();
  // waving arm
  const waveAngle = Math.sin(animFrame * Math.PI * 6) * .3;
  ctx.strokeStyle = '#06d6a0'; ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(rx + H*.025, alienInRocketY);
  ctx.lineTo(rx + H*.05, alienInRocketY - H*.02 + Math.sin(waveAngle) * H*.02);
  ctx.stroke();

  ctx.restore();

  // smoke trail
  ctx.fillStyle = 'rgba(200,200,200,.2)';
  for (let i = 0; i < 8; i++) {
    const sx = rx + (Math.sin(i * 3 + Date.now()/200) * H * .06);
    const sy = ry + H * .02 + i * H * .04;
    const sr = H * .015 + i * H * .012;
    ctx.beginPath(); ctx.arc(sx, sy, sr, 0, Math.PI * 2); ctx.fill();
  }
}

function drawStar(ctx, x, y, points, outer, inner) {
  ctx.beginPath();
  for (let i = 0; i < points * 2; i++) {
    const r = i % 2 === 0 ? outer : inner;
    const angle = (i * Math.PI / points) - Math.PI / 2;
    if (i === 0) ctx.moveTo(x + r * Math.cos(angle), y + r * Math.sin(angle));
    else ctx.lineTo(x + r * Math.cos(angle), y + r * Math.sin(angle));
  }
  ctx.closePath(); ctx.fill();
}

// ============== DINO THEME ==============
function drawDino() {
  const { ctx, W, H } = getCanvas();
  ctx.clearRect(0, 0, W, H);
  const cx = W * .5, groundY = H * .92;

  // ground
  ctx.fillStyle = '#5a4a2a';
  ctx.fillRect(0, groundY, W, H - groundY);
  // grass tufts
  ctx.fillStyle = '#3a7a2a';
  for (let i = 0; i < 12; i++) {
    const gx = W * (i / 12) + W * .04;
    ctx.beginPath();
    ctx.moveTo(gx - 6, groundY);
    ctx.lineTo(gx, groundY - 10 - Math.random() * 5);
    ctx.lineTo(gx + 6, groundY);
    ctx.fill();
  }

  // small volcano in background
  ctx.fillStyle = '#654321';
  ctx.beginPath();
  ctx.moveTo(W * .7, groundY);
  ctx.lineTo(W * .8, groundY - H * .25);
  ctx.lineTo(W * .9, groundY);
  ctx.closePath(); ctx.fill();
  // volcano top
  ctx.fillStyle = '#8B0000';
  ctx.beginPath();
  ctx.moveTo(W * .77, groundY - H * .2);
  ctx.lineTo(W * .8, groundY - H * .25);
  ctx.lineTo(W * .83, groundY - H * .2);
  ctx.closePath(); ctx.fill();

  // Egg
  const eggX = cx, eggY = groundY - H * .18;
  const eggW = H * .16, eggH = H * .22;

  if (gameOver && animFrame > 0 && wrongCount >= MAX_WRONG) {
    // Lose: dino pops out and runs off
    drawDinoLose(ctx, eggX, eggY, eggW, eggH, W, H, groundY);
  } else if (gameOver && animFrame > 0 && wrongCount < MAX_WRONG) {
    // Win: dino hatches and dances
    drawDinoWin(ctx, eggX, eggY, eggW, eggH, W, H, groundY);
  } else {
    // Draw egg with cracks
    drawEgg(ctx, eggX, eggY, eggW, eggH, wrongCount);
  }
}

function drawEgg(ctx, x, y, w, h, cracks) {
  // egg shadow
  ctx.fillStyle = 'rgba(0,0,0,.15)';
  ctx.beginPath(); ctx.ellipse(x, y + h * .85, w * .8, h * .1, 0, 0, Math.PI * 2); ctx.fill();

  // egg body
  ctx.fillStyle = '#FFF8E7';
  ctx.strokeStyle = '#D4C5A9';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.ellipse(x, y, w, h, 0, 0, Math.PI * 2);
  ctx.fill(); ctx.stroke();

  // spots
  ctx.fillStyle = '#E8D5B7';
  [[-.3, -.2, .08], [.2, .1, .06], [-.1, .3, .07], [.25, -.3, .05]].forEach(([ox, oy, r]) => {
    ctx.beginPath(); ctx.arc(x + w * ox, y + h * oy, h * r, 0, Math.PI * 2); ctx.fill();
  });

  // cracks
  ctx.strokeStyle = '#8B7355';
  ctx.lineWidth = 2;
  ctx.lineCap = 'round';
  const crackPaths = [
    // crack 1: top
    [[0, -.7], [-.1, -.5], [.05, -.35]],
    // crack 2: top right
    [[.3, -.5], [.2, -.3], [.35, -.15]],
    // crack 3: left
    [[-.5, -.1], [-.35, .05], [-.45, .2]],
    // crack 4: right
    [[.5, .0], [.35, .15], [.5, .25]],
    // crack 5: bottom left
    [[-.3, .3], [-.15, .45], [-.25, .55]],
    // crack 6: big crack across middle
    [[-.4, -.1], [-.1, 0], [.1, -.05], [.3, .1]]
  ];
  for (let i = 0; i < cracks && i < crackPaths.length; i++) {
    const path = crackPaths[i];
    ctx.beginPath();
    ctx.moveTo(x + w * path[0][0], y + h * path[0][1]);
    for (let j = 1; j < path.length; j++) {
      ctx.lineTo(x + w * path[j][0], y + h * path[j][1]);
    }
    ctx.stroke();
  }

  // If many cracks, show peeking eye
  if (cracks >= 4) {
    ctx.fillStyle = '#06d6a0';
    ctx.beginPath(); ctx.arc(x + w * .15, y - h * .1, h * .06, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#0b0e2d';
    ctx.beginPath(); ctx.arc(x + w * .15, y - h * .12, h * .03, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.arc(x + w * .17, y - h * .13, h * .01, 0, Math.PI * 2); ctx.fill();
  }
}

function drawBabyDino(ctx, x, y, H, flip) {
  const sz = H * .06;
  ctx.save();
  if (flip) { ctx.translate(x, 0); ctx.scale(-1, 1); ctx.translate(-x, 0); }
  // body
  ctx.fillStyle = '#06d6a0';
  ctx.beginPath(); ctx.ellipse(x, y, sz * 1.2, sz * .8, 0, 0, Math.PI * 2); ctx.fill();
  // head
  ctx.beginPath(); ctx.arc(x + sz * .9, y - sz * .5, sz * .6, 0, Math.PI * 2); ctx.fill();
  // eye
  ctx.fillStyle = '#0b0e2d';
  ctx.beginPath(); ctx.arc(x + sz * 1.1, y - sz * .6, sz * .12, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#fff';
  ctx.beginPath(); ctx.arc(x + sz * 1.15, y - sz * .65, sz * .05, 0, Math.PI * 2); ctx.fill();
  // mouth smile
  ctx.strokeStyle = '#0b0e2d'; ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.arc(x + sz * 1.2, y - sz * .4, sz * .15, 0, Math.PI * .8); ctx.stroke();
  // legs
  ctx.fillStyle = '#06d6a0';
  ctx.fillRect(x - sz * .4, y + sz * .5, sz * .25, sz * .35);
  ctx.fillRect(x + sz * .2, y + sz * .5, sz * .25, sz * .35);
  // feet
  ctx.fillStyle = '#05b58a';
  ctx.beginPath(); ctx.ellipse(x - sz * .3, y + sz * .88, sz * .18, sz * .08, 0, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(x + sz * .3, y + sz * .88, sz * .18, sz * .08, 0, 0, Math.PI * 2); ctx.fill();
  // tail
  ctx.strokeStyle = '#06d6a0'; ctx.lineWidth = sz * .25; ctx.lineCap = 'round';
  ctx.beginPath();
  ctx.moveTo(x - sz * .9, y);
  ctx.quadraticCurveTo(x - sz * 1.5, y - sz * .3, x - sz * 1.3, y - sz * .8);
  ctx.stroke();
  // spikes on back
  ctx.fillStyle = '#ffd166';
  for (let i = 0; i < 3; i++) {
    const spx = x + sz * (.3 - i * .4);
    const spy = y - sz * .7;
    ctx.beginPath();
    ctx.moveTo(spx - sz * .08, spy + sz * .1);
    ctx.lineTo(spx, spy - sz * .15);
    ctx.lineTo(spx + sz * .08, spy + sz * .1);
    ctx.fill();
  }
  ctx.restore();
}

function drawDinoWin(ctx, eggX, eggY, eggW, eggH, W, H, groundY) {
  // Dino hatches and dances (bounces side to side)
  const dinoY = groundY - H * .07;
  const bounce = Math.sin(animFrame * Math.PI * 6) * 8;
  const wobble = Math.sin(animFrame * Math.PI * 4) * 5;
  drawBabyDino(ctx, eggX + wobble, dinoY + bounce, H, false);

  // egg shell pieces
  ctx.fillStyle = '#FFF8E7'; ctx.strokeStyle = '#D4C5A9'; ctx.lineWidth = 1.5;
  // left shell half
  ctx.beginPath();
  ctx.ellipse(eggX - eggW * .6, groundY - eggH * .15, eggW * .4, eggH * .3, -.3, 0, Math.PI);
  ctx.fill(); ctx.stroke();
  // right shell half
  ctx.beginPath();
  ctx.ellipse(eggX + eggW * .6, groundY - eggH * .15, eggW * .4, eggH * .3, .3, 0, Math.PI);
  ctx.fill(); ctx.stroke();

  // hearts
  const heartColors = ['#f72585', '#ef476f', '#ffd166'];
  for (let i = 0; i < 4; i++) {
    const angle = (i / 4) * Math.PI * 2 + animFrame * Math.PI * 3;
    const dist = H * .12 * animFrame;
    const hx = eggX + Math.cos(angle) * dist;
    const hy = dinoY - H * .08 + Math.sin(angle) * dist * .5 - animFrame * H * .1;
    ctx.fillStyle = heartColors[i % heartColors.length];
    ctx.globalAlpha = Math.max(0, 1 - animFrame * .8);
    drawHeart(ctx, hx, hy, H * .015);
    ctx.globalAlpha = 1;
  }
}

function drawDinoLose(ctx, eggX, eggY, eggW, eggH, W, H, groundY) {
  // Dino pops out and runs right off screen
  const dinoY = groundY - H * .07;
  const runX = eggX + animFrame * W * .8;
  const bounce = Math.sin(animFrame * Math.PI * 12) * 5;
  drawBabyDino(ctx, runX, dinoY + bounce, H, false);

  // egg shell pieces left behind
  ctx.fillStyle = '#FFF8E7'; ctx.strokeStyle = '#D4C5A9'; ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.ellipse(eggX - eggW * .4, groundY - eggH * .1, eggW * .35, eggH * .25, -.2, 0, Math.PI);
  ctx.fill(); ctx.stroke();
  ctx.beginPath();
  ctx.ellipse(eggX + eggW * .3, groundY - eggH * .1, eggW * .3, eggH * .2, .3, 0, Math.PI);
  ctx.fill(); ctx.stroke();

  // little dust puffs behind dino
  ctx.fillStyle = 'rgba(200,180,150,.3)';
  for (let i = 0; i < 4; i++) {
    const px = runX - H * .1 - i * H * .05;
    const py = dinoY + H * .02;
    ctx.beginPath(); ctx.arc(px, py, H * .015 + i * H * .005, 0, Math.PI * 2); ctx.fill();
  }
}

function drawHeart(ctx, x, y, sz) {
  ctx.beginPath();
  ctx.moveTo(x, y + sz * .5);
  ctx.bezierCurveTo(x - sz, y - sz * .2, x - sz * .5, y - sz, x, y - sz * .4);
  ctx.bezierCurveTo(x + sz * .5, y - sz, x + sz, y - sz * .2, x, y + sz * .5);
  ctx.fill();
}

// ============== OCEAN THEME ==============
function drawOcean() {
  const { ctx, W, H } = getCanvas();
  ctx.clearRect(0, 0, W, H);
  const groundY = H * .92;

  // ocean floor
  ctx.fillStyle = '#1a4a3a';
  ctx.beginPath();
  ctx.moveTo(0, groundY);
  for (let x = 0; x <= W; x += W/8) {
    ctx.lineTo(x, groundY + Math.sin(x/W * Math.PI * 3) * 8);
  }
  ctx.lineTo(W, H); ctx.lineTo(0, H); ctx.closePath(); ctx.fill();

  // seaweed
  const time = Date.now() / 1000;
  ctx.strokeStyle = '#2a8a4a'; ctx.lineWidth = 4; ctx.lineCap = 'round';
  [.15, .35, .7, .85].forEach((xp, i) => {
    const baseX = W * xp;
    ctx.beginPath();
    ctx.moveTo(baseX, groundY);
    const sway = Math.sin(time + i * 2) * 8;
    ctx.quadraticCurveTo(baseX + sway, groundY - H * .1, baseX + sway * 1.5, groundY - H * .18);
    ctx.stroke();
  });

  // Fish always visible
  const fishX = W * .25, fishY = H * .55;
  if (gameOver && animFrame > 0 && wrongCount >= MAX_WRONG) {
    drawOceanLose(ctx, fishX, fishY, W, H);
  } else if (gameOver && animFrame > 0 && wrongCount < MAX_WRONG) {
    drawOceanWin(ctx, fishX, fishY, W, H);
  } else {
    drawFish(ctx, fishX, fishY, H, false);
    // bubbles based on wrong guesses
    drawWrongBubbles(ctx, fishX, fishY, W, H, wrongCount);
  }
}

function drawFish(ctx, x, y, H, flip) {
  const sz = H * .07;
  ctx.save();
  if (flip) { ctx.translate(x, 0); ctx.scale(-1, 1); ctx.translate(-x, 0); }

  // body
  ctx.fillStyle = '#ff9f43';
  ctx.beginPath();
  ctx.ellipse(x, y, sz * 1.5, sz, 0, 0, Math.PI * 2);
  ctx.fill();

  // stripes
  ctx.fillStyle = '#ffd166';
  ctx.beginPath();
  ctx.ellipse(x - sz * .2, y, sz * .15, sz * .8, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(x + sz * .4, y, sz * .15, sz * .7, 0, 0, Math.PI * 2);
  ctx.fill();

  // tail
  ctx.fillStyle = '#f72585';
  ctx.beginPath();
  ctx.moveTo(x - sz * 1.3, y);
  ctx.lineTo(x - sz * 2, y - sz * .6);
  ctx.lineTo(x - sz * 2, y + sz * .6);
  ctx.closePath(); ctx.fill();

  // dorsal fin
  ctx.fillStyle = '#f72585';
  ctx.beginPath();
  ctx.moveTo(x - sz * .2, y - sz * .9);
  ctx.lineTo(x + sz * .3, y - sz * 1.2);
  ctx.lineTo(x + sz * .5, y - sz * .85);
  ctx.closePath(); ctx.fill();

  // eye
  ctx.fillStyle = '#fff';
  ctx.beginPath(); ctx.arc(x + sz * .8, y - sz * .15, sz * .25, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#0b0e2d';
  ctx.beginPath(); ctx.arc(x + sz * .85, y - sz * .15, sz * .12, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#fff';
  ctx.beginPath(); ctx.arc(x + sz * .9, y - sz * .2, sz * .05, 0, Math.PI * 2); ctx.fill();

  // mouth smile
  ctx.strokeStyle = '#e67e22'; ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.arc(x + sz * 1.0, y + sz * .1, sz * .15, -.2, Math.PI * .6); ctx.stroke();

  ctx.restore();
}

function drawWrongBubbles(ctx, fishX, fishY, W, H, count) {
  const bubblePositions = [
    [.45, .48], [.55, .38], [.48, .28], [.58, .2], [.52, .12], [.56, .05]
  ];
  for (let i = 0; i < count && i < bubblePositions.length; i++) {
    const bx = W * bubblePositions[i][0];
    const by = H * bubblePositions[i][1];
    const br = H * .025 + i * H * .003;
    // bubble
    ctx.fillStyle = 'rgba(160,196,255,.2)';
    ctx.strokeStyle = 'rgba(160,196,255,.6)';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(bx, by, br, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
    // shine
    ctx.fillStyle = 'rgba(255,255,255,.3)';
    ctx.beginPath(); ctx.arc(bx - br * .25, by - br * .25, br * .25, 0, Math.PI * 2); ctx.fill();
  }
}

function drawOceanWin(ctx, fishX, fishY, W, H) {
  // fish does a flip
  const angle = animFrame * Math.PI * 2;
  const sz = H * .07;
  ctx.save();
  ctx.translate(fishX, fishY);
  ctx.rotate(angle);
  ctx.translate(-fishX, -fishY);
  drawFish(ctx, fishX, fishY, H, false);
  ctx.restore();

  // heart bubble
  if (animFrame > .5) {
    const hbProgress = (animFrame - .5) * 2;
    const hbx = fishX + sz * 2;
    const hby = fishY - sz * 1.5 - hbProgress * H * .05;
    ctx.fillStyle = '#f72585';
    ctx.globalAlpha = 1 - hbProgress * .5;
    drawHeart(ctx, hbx, hby, H * .025);
    // bubble around heart
    ctx.strokeStyle = 'rgba(160,196,255,.5)';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(hbx, hby, H * .035, 0, Math.PI * 2); ctx.stroke();
    ctx.globalAlpha = 1;
  }
}

function drawOceanLose(ctx, fishX, fishY, W, H) {
  // fish floats up and swims off to the right
  const swimX = fishX + animFrame * W * .6;
  const floatY = fishY - animFrame * H * .5;
  const wobble = Math.sin(animFrame * Math.PI * 8) * 5;
  drawFish(ctx, swimX, floatY + wobble, H, false);

  // trail of tiny bubbles
  ctx.fillStyle = 'rgba(160,196,255,.2)';
  for (let i = 0; i < 6; i++) {
    const tbx = swimX - H * .08 * (i + 1);
    const tby = floatY + H * .01 * i + wobble;
    ctx.beginPath(); ctx.arc(tbx, tby, H * .01 + i * H * .003, 0, Math.PI * 2); ctx.fill();
  }

  // remaining bubbles stay
  drawWrongBubbles(ctx, fishX, fishY, W, H, MAX_WRONG);
}

// ============== JUNGLE THEME ==============
function drawJungle() {
  const { ctx, W, H } = getCanvas();
  ctx.clearRect(0, 0, W, H);
  const groundY = H * .92;

  // ground
  ctx.fillStyle = '#3a2a1a';
  ctx.fillRect(0, groundY, W, H - groundY);
  // grass
  ctx.fillStyle = '#2a6a1a';
  for (let i = 0; i < 15; i++) {
    const gx = W * (i / 15) + W * .03;
    ctx.beginPath();
    ctx.moveTo(gx - 8, groundY);
    ctx.lineTo(gx, groundY - 12);
    ctx.lineTo(gx + 8, groundY);
    ctx.fill();
  }

  // background vines
  ctx.strokeStyle = '#1a5a0a'; ctx.lineWidth = 3; ctx.lineCap = 'round';
  const time = Date.now() / 2000;
  [[.05, .15], [.9, .2], [.75, .1]].forEach(([xp, len], i) => {
    const vx = W * xp;
    const sway = Math.sin(time + i * 2) * 5;
    ctx.beginPath();
    ctx.moveTo(vx, 0);
    ctx.quadraticCurveTo(vx + sway, H * len * .5, vx + sway * 1.5, H * len);
    ctx.stroke();
    // leaf at end
    ctx.fillStyle = '#2a8a1a';
    ctx.beginPath();
    ctx.ellipse(vx + sway * 1.5, H * len, 6, 10, sway * .1, 0, Math.PI * 2);
    ctx.fill();
  });

  // tropical flowers in background
  ctx.fillStyle = '#f72585';
  [[.12, .35, 4], [.88, .28, 3.5], [.82, .45, 4.5]].forEach(([xp, yp, r]) => {
    const fx = W * xp, fy = H * yp;
    for (let p = 0; p < 5; p++) {
      const angle = (p / 5) * Math.PI * 2;
      ctx.beginPath();
      ctx.ellipse(fx + Math.cos(angle) * r * 1.5, fy + Math.sin(angle) * r * 1.5, r, r * .6, angle, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.fillStyle = '#ffd166';
    ctx.beginPath(); ctx.arc(fx, fy, r * .8, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#f72585';
  });

  // Tree trunk
  const treeX = W * .5, treeBase = groundY;
  ctx.fillStyle = '#5a3a1a';
  ctx.beginPath();
  ctx.moveTo(treeX - H * .04, treeBase);
  ctx.lineTo(treeX - H * .03, treeBase - H * .75);
  ctx.lineTo(treeX + H * .03, treeBase - H * .75);
  ctx.lineTo(treeX + H * .04, treeBase);
  ctx.closePath(); ctx.fill();
  // bark lines
  ctx.strokeStyle = '#4a2a0a'; ctx.lineWidth = 1;
  for (let i = 0; i < 6; i++) {
    const by = treeBase - H * .1 - i * H * .1;
    ctx.beginPath();
    ctx.moveTo(treeX - H * .02, by);
    ctx.lineTo(treeX + H * .01, by - H * .02);
    ctx.stroke();
  }

  // Branches (6 levels)
  const branchYs = [];
  for (let i = 0; i < 6; i++) {
    const by = treeBase - H * .15 - i * H * .11;
    branchYs.push(by);
    const dir = i % 2 === 0 ? 1 : -1;
    const blen = H * .12 + (i % 3) * H * .02;
    ctx.strokeStyle = '#5a3a1a'; ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(treeX, by);
    ctx.lineTo(treeX + dir * blen, by - H * .02);
    ctx.stroke();
    // leaves on branch
    ctx.fillStyle = '#2a8a1a';
    const leafX = treeX + dir * blen;
    ctx.beginPath();
    ctx.ellipse(leafX, by - H * .03, H * .04, H * .02, dir * .3, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#3aaa2a';
    ctx.beginPath();
    ctx.ellipse(leafX - dir * H * .02, by - H * .015, H * .03, H * .015, dir * -.2, 0, Math.PI * 2);
    ctx.fill();
  }

  // Monkey
  const monkeyBranch = Math.min(wrongCount, 6);
  if (gameOver && animFrame > 0 && wrongCount >= MAX_WRONG) {
    drawJungleLose(ctx, treeX, branchYs, W, H, groundY);
  } else if (gameOver && animFrame > 0 && wrongCount < MAX_WRONG) {
    drawJungleWin(ctx, treeX, branchYs, W, H, groundY, monkeyBranch);
  } else {
    // monkey at current branch level (0 = ground, 1-6 = branches)
    if (monkeyBranch === 0) {
      drawMonkey(ctx, treeX - H * .1, groundY - H * .08, H);
    } else {
      const by = branchYs[monkeyBranch - 1];
      const dir = (monkeyBranch - 1) % 2 === 0 ? 1 : -1;
      const blen = H * .12 + ((monkeyBranch - 1) % 3) * H * .02;
      drawMonkey(ctx, treeX + dir * blen * .7, by - H * .07, H);
    }
  }
}

function drawMonkey(ctx, x, y, H) {
  const sz = H * .05;
  // body
  ctx.fillStyle = '#8B4513';
  ctx.beginPath(); ctx.ellipse(x, y, sz * .8, sz * 1.1, 0, 0, Math.PI * 2); ctx.fill();
  // belly
  ctx.fillStyle = '#D2A679';
  ctx.beginPath(); ctx.ellipse(x, y + sz * .2, sz * .5, sz * .6, 0, 0, Math.PI * 2); ctx.fill();
  // head
  ctx.fillStyle = '#8B4513';
  ctx.beginPath(); ctx.arc(x, y - sz * 1.2, sz * .7, 0, Math.PI * 2); ctx.fill();
  // face
  ctx.fillStyle = '#D2A679';
  ctx.beginPath(); ctx.ellipse(x, y - sz * 1.1, sz * .5, sz * .45, 0, 0, Math.PI * 2); ctx.fill();
  // eyes
  ctx.fillStyle = '#0b0e2d';
  ctx.beginPath(); ctx.arc(x - sz * .2, y - sz * 1.25, sz * .1, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(x + sz * .2, y - sz * 1.25, sz * .1, 0, Math.PI * 2); ctx.fill();
  // eye shine
  ctx.fillStyle = '#fff';
  ctx.beginPath(); ctx.arc(x - sz * .17, y - sz * 1.28, sz * .04, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(x + sz * .23, y - sz * 1.28, sz * .04, 0, Math.PI * 2); ctx.fill();
  // smile
  ctx.strokeStyle = '#5a2a0a'; ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.arc(x, y - sz * 1.05, sz * .2, .1 * Math.PI, .9 * Math.PI); ctx.stroke();
  // ears
  ctx.fillStyle = '#D2A679';
  ctx.beginPath(); ctx.arc(x - sz * .65, y - sz * 1.2, sz * .2, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(x + sz * .65, y - sz * 1.2, sz * .2, 0, Math.PI * 2); ctx.fill();
  // arms
  ctx.strokeStyle = '#8B4513'; ctx.lineWidth = sz * .2; ctx.lineCap = 'round';
  ctx.beginPath(); ctx.moveTo(x - sz * .7, y - sz * .2); ctx.lineTo(x - sz * 1.1, y + sz * .2); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(x + sz * .7, y - sz * .2); ctx.lineTo(x + sz * 1.1, y + sz * .2); ctx.stroke();
  // legs
  ctx.beginPath(); ctx.moveTo(x - sz * .3, y + sz * .9); ctx.lineTo(x - sz * .5, y + sz * 1.4); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(x + sz * .3, y + sz * .9); ctx.lineTo(x + sz * .5, y + sz * 1.4); ctx.stroke();
  // tail
  ctx.strokeStyle = '#8B4513'; ctx.lineWidth = sz * .15;
  ctx.beginPath();
  ctx.moveTo(x + sz * .6, y + sz * .5);
  ctx.quadraticCurveTo(x + sz * 1.5, y + sz * .2, x + sz * 1.3, y - sz * .3);
  ctx.stroke();
}

function drawJungleWin(ctx, treeX, branchYs, W, H, groundY, monkeyBranch) {
  // monkey at ground doing happy dance + banana falling
  const bounce = Math.sin(animFrame * Math.PI * 6) * 8;
  const wobble = Math.sin(animFrame * Math.PI * 4) * 6;
  drawMonkey(ctx, treeX - H * .1 + wobble, groundY - H * .08 + bounce, H);

  // banana falling from tree
  const bananaY = branchYs[0] + animFrame * (groundY - branchYs[0] - H * .2);
  const bananaX = treeX + H * .15;
  const bananaRot = animFrame * Math.PI * 3;
  ctx.save();
  ctx.translate(bananaX, Math.min(bananaY, groundY - H * .15));
  ctx.rotate(bananaRot);
  // banana shape
  ctx.fillStyle = '#ffd166';
  ctx.beginPath();
  ctx.moveTo(0, -H * .03);
  ctx.quadraticCurveTo(H * .04, 0, 0, H * .03);
  ctx.quadraticCurveTo(-H * .02, 0, 0, -H * .03);
  ctx.fill();
  ctx.strokeStyle = '#e6b800'; ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(0, -H * .03);
  ctx.quadraticCurveTo(H * .04, 0, 0, H * .03);
  ctx.stroke();
  ctx.restore();

  // sparkles around monkey
  const sparkleColors = ['#ffd166', '#f72585', '#06d6a0', '#ff9f43'];
  for (let i = 0; i < 6; i++) {
    const angle = (i / 6) * Math.PI * 2 + animFrame * Math.PI * 2;
    const dist = H * .1 * animFrame;
    const sx = treeX - H * .1 + Math.cos(angle) * dist;
    const sy = groundY - H * .08 + Math.sin(angle) * dist;
    ctx.fillStyle = sparkleColors[i % sparkleColors.length];
    ctx.globalAlpha = Math.max(0, 1 - animFrame * .7);
    drawStar(ctx, sx, sy, 4, H * .015, H * .007);
    ctx.globalAlpha = 1;
  }
}

function drawJungleLose(ctx, treeX, branchYs, W, H, groundY) {
  // monkey at top swings away on vine
  const topY = branchYs[5] - H * .07;
  // vine swing arc
  const swingAngle = animFrame * Math.PI * .8;
  const vineStartX = treeX;
  const vineStartY = branchYs[5] - H * .15;
  const vineLen = H * .3;
  const monkeyX = vineStartX + Math.sin(swingAngle) * vineLen + animFrame * W * .3;
  const monkeyY = vineStartY + Math.cos(swingAngle) * vineLen * .3 - animFrame * H * .2;

  // draw vine
  ctx.strokeStyle = '#1a5a0a'; ctx.lineWidth = 3; ctx.lineCap = 'round';
  ctx.beginPath();
  ctx.moveTo(vineStartX, 0);
  ctx.quadraticCurveTo(vineStartX + Math.sin(swingAngle) * vineLen * .5, vineStartY * .5, monkeyX, monkeyY + H * .05);
  ctx.stroke();
  // leaf on vine
  ctx.fillStyle = '#2a8a1a';
  ctx.beginPath();
  ctx.ellipse(vineStartX, H * .02, 8, 14, 0, 0, Math.PI * 2);
  ctx.fill();

  drawMonkey(ctx, monkeyX, monkeyY, H);

  // trailing leaves
  ctx.fillStyle = 'rgba(42,138,26,.4)';
  for (let i = 0; i < 4; i++) {
    const lx = monkeyX - H * .06 * (i + 1);
    const ly = monkeyY + H * .03 * i;
    ctx.beginPath();
    ctx.ellipse(lx, ly, H * .01 + i * H * .003, H * .006 + i * H * .002, i * .5, 0, Math.PI * 2);
    ctx.fill();
  }
}

// ============== ARCTIC THEME ==============
function drawArctic() {
  const { ctx, W, H } = getCanvas();
  ctx.clearRect(0, 0, W, H);
  const groundY = H * .92;

  // snowy ground
  ctx.fillStyle = '#e8f0f8';
  ctx.beginPath();
  ctx.moveTo(0, groundY);
  for (let x = 0; x <= W; x += W / 10) {
    ctx.lineTo(x, groundY - Math.sin(x / W * Math.PI * 4) * 4 - 2);
  }
  ctx.lineTo(W, H); ctx.lineTo(0, H); ctx.closePath(); ctx.fill();

  // snow sparkles on ground
  ctx.fillStyle = 'rgba(255,255,255,.6)';
  for (let i = 0; i < 20; i++) {
    const sx = W * ((i * 7 + 3) % 20) / 20;
    const sy = groundY + 2 + (i % 3) * 3;
    ctx.beginPath(); ctx.arc(sx, sy, 1.5, 0, Math.PI * 2); ctx.fill();
  }

  // distant mountains
  ctx.fillStyle = '#b0c8e0';
  ctx.beginPath();
  ctx.moveTo(0, groundY);
  ctx.lineTo(W * .1, groundY - H * .2);
  ctx.lineTo(W * .25, groundY - H * .35);
  ctx.lineTo(W * .4, groundY - H * .15);
  ctx.lineTo(W * .55, groundY - H * .3);
  ctx.lineTo(W * .7, groundY - H * .18);
  ctx.lineTo(W * .85, groundY - H * .28);
  ctx.lineTo(W, groundY - H * .1);
  ctx.lineTo(W, groundY);
  ctx.closePath(); ctx.fill();
  // snow caps
  ctx.fillStyle = '#dce8f0';
  ctx.beginPath();
  ctx.moveTo(W * .2, groundY - H * .3);
  ctx.lineTo(W * .25, groundY - H * .35);
  ctx.lineTo(W * .3, groundY - H * .28);
  ctx.closePath(); ctx.fill();
  ctx.beginPath();
  ctx.moveTo(W * .5, groundY - H * .25);
  ctx.lineTo(W * .55, groundY - H * .3);
  ctx.lineTo(W * .6, groundY - H * .23);
  ctx.closePath(); ctx.fill();

  // snowflakes falling
  ctx.fillStyle = 'rgba(255,255,255,.5)';
  const time = Date.now() / 1000;
  for (let i = 0; i < 12; i++) {
    const sfx = (W * ((i * 13 + 7) % 12) / 12 + Math.sin(time + i * 3) * 15) % W;
    const sfy = ((time * 20 + i * 80) % (H * 1.1)) - H * .05;
    const sfr = 1.5 + (i % 3);
    ctx.beginPath(); ctx.arc(sfx, sfy, sfr, 0, Math.PI * 2); ctx.fill();
  }

  // Igloo position
  const iglooX = W * .65, iglooBaseY = groundY;

  // Penguin and igloo
  if (gameOver && animFrame > 0 && wrongCount >= MAX_WRONG) {
    drawArcticLose(ctx, iglooX, iglooBaseY, W, H, groundY);
  } else if (gameOver && animFrame > 0 && wrongCount < MAX_WRONG) {
    drawArcticWin(ctx, iglooX, iglooBaseY, W, H, groundY);
  } else {
    // draw igloo blocks based on wrong count
    drawIgloo(ctx, iglooX, iglooBaseY, H, wrongCount);
    // penguin standing nearby
    drawPenguin(ctx, W * .3, groundY - H * .08, H);
  }
}

function drawPenguin(ctx, x, y, H) {
  const sz = H * .055;
  // body
  ctx.fillStyle = '#1a1a2e';
  ctx.beginPath(); ctx.ellipse(x, y, sz * .9, sz * 1.2, 0, 0, Math.PI * 2); ctx.fill();
  // belly
  ctx.fillStyle = '#f0f0f0';
  ctx.beginPath(); ctx.ellipse(x, y + sz * .15, sz * .6, sz * .85, 0, 0, Math.PI * 2); ctx.fill();
  // head
  ctx.fillStyle = '#1a1a2e';
  ctx.beginPath(); ctx.arc(x, y - sz * 1.2, sz * .65, 0, Math.PI * 2); ctx.fill();
  // white face patch
  ctx.fillStyle = '#f0f0f0';
  ctx.beginPath(); ctx.ellipse(x, y - sz * 1.1, sz * .4, sz * .35, 0, 0, Math.PI * 2); ctx.fill();
  // eyes
  ctx.fillStyle = '#0b0e2d';
  ctx.beginPath(); ctx.arc(x - sz * .18, y - sz * 1.25, sz * .09, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(x + sz * .18, y - sz * 1.25, sz * .09, 0, Math.PI * 2); ctx.fill();
  // eye shine
  ctx.fillStyle = '#fff';
  ctx.beginPath(); ctx.arc(x - sz * .15, y - sz * 1.28, sz * .035, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(x + sz * .21, y - sz * 1.28, sz * .035, 0, Math.PI * 2); ctx.fill();
  // beak
  ctx.fillStyle = '#ff9f43';
  ctx.beginPath();
  ctx.moveTo(x, y - sz * 1.1);
  ctx.lineTo(x - sz * .15, y - sz * .95);
  ctx.lineTo(x + sz * .15, y - sz * .95);
  ctx.closePath(); ctx.fill();
  // flippers
  ctx.fillStyle = '#1a1a2e';
  ctx.beginPath();
  ctx.ellipse(x - sz * .85, y + sz * .1, sz * .2, sz * .55, .3, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(x + sz * .85, y + sz * .1, sz * .2, sz * .55, -.3, 0, Math.PI * 2);
  ctx.fill();
  // feet
  ctx.fillStyle = '#ff9f43';
  ctx.beginPath(); ctx.ellipse(x - sz * .3, y + sz * 1.15, sz * .2, sz * .08, -.2, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(x + sz * .3, y + sz * 1.15, sz * .2, sz * .08, .2, 0, Math.PI * 2); ctx.fill();
}

function drawIgloo(ctx, x, y, H, blocks) {
  // igloo is built from bottom up, 6 stages
  const iglooW = H * .22, iglooH = H * .2;

  if (blocks >= 1) {
    // base row left
    ctx.fillStyle = '#d0e8f8'; ctx.strokeStyle = '#a0c0d8'; ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.roundRect(x - iglooW * .5, y - iglooH * .2, iglooW * .35, iglooH * .2, 3);
    ctx.fill(); ctx.stroke();
  }
  if (blocks >= 2) {
    // base row right
    ctx.fillStyle = '#d0e8f8'; ctx.strokeStyle = '#a0c0d8'; ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.roundRect(x - iglooW * .1, y - iglooH * .2, iglooW * .35, iglooH * .2, 3);
    ctx.fill(); ctx.stroke();
  }
  if (blocks >= 3) {
    // second row left
    ctx.fillStyle = '#d8ecfa'; ctx.strokeStyle = '#a0c0d8'; ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.roundRect(x - iglooW * .45, y - iglooH * .42, iglooW * .33, iglooH * .2, 3);
    ctx.fill(); ctx.stroke();
  }
  if (blocks >= 4) {
    // second row right
    ctx.fillStyle = '#d8ecfa'; ctx.strokeStyle = '#a0c0d8'; ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.roundRect(x - iglooW * .08, y - iglooH * .42, iglooW * .33, iglooH * .2, 3);
    ctx.fill(); ctx.stroke();
  }
  if (blocks >= 5) {
    // top row
    ctx.fillStyle = '#e0f0ff'; ctx.strokeStyle = '#a0c0d8'; ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.roundRect(x - iglooW * .35, y - iglooH * .62, iglooW * .45, iglooH * .18, 3);
    ctx.fill(); ctx.stroke();
  }
  if (blocks >= 6) {
    // dome cap
    ctx.fillStyle = '#e8f4ff'; ctx.strokeStyle = '#a0c0d8'; ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.arc(x - iglooW * .12, y - iglooH * .62, iglooW * .28, Math.PI, 0);
    ctx.fill(); ctx.stroke();
    // doorway
    ctx.fillStyle = '#6a9abc';
    ctx.beginPath();
    ctx.arc(x + iglooW * .25, y - iglooH * .05, iglooH * .12, Math.PI, 0, true);
    ctx.lineTo(x + iglooW * .25 + iglooH * .12, y);
    ctx.lineTo(x + iglooW * .25 - iglooH * .12, y);
    ctx.closePath(); ctx.fill();
  }

  // snow on top of whatever is built
  if (blocks > 0) {
    ctx.fillStyle = 'rgba(255,255,255,.4)';
    const topY = blocks >= 6 ? y - iglooH * .85 : blocks >= 5 ? y - iglooH * .62 : blocks >= 3 ? y - iglooH * .42 : y - iglooH * .2;
    for (let i = 0; i < 4; i++) {
      const sx = x - iglooW * .4 + i * iglooW * .2;
      ctx.beginPath(); ctx.arc(sx, topY, H * .01, 0, Math.PI * 2); ctx.fill();
    }
  }
}

function drawArcticWin(ctx, iglooX, iglooBaseY, W, H, groundY) {
  // penguin belly slide across ice
  const penguinX = W * .3 + animFrame * W * .3;
  const slideY = groundY - H * .04;
  const wobble = Math.sin(animFrame * Math.PI * 8) * 2;

  // draw penguin on belly (rotated)
  ctx.save();
  ctx.translate(penguinX, slideY + wobble);
  ctx.rotate(-Math.PI * .5);
  ctx.translate(-penguinX, -(slideY + wobble));
  drawPenguin(ctx, penguinX, slideY + wobble, H);
  ctx.restore();

  // ice spray behind
  ctx.fillStyle = 'rgba(200,230,255,.4)';
  for (let i = 0; i < 5; i++) {
    const ix = penguinX - H * .05 - i * H * .03;
    const iy = slideY + H * .02 - Math.random() * H * .02;
    ctx.beginPath(); ctx.arc(ix, iy, H * .008 + i * H * .003, 0, Math.PI * 2); ctx.fill();
  }

  // sparkles
  const sparkleColors = ['#a0c4ff', '#fff', '#d0e8f8', '#ffd166'];
  for (let i = 0; i < 6; i++) {
    const angle = (i / 6) * Math.PI * 2 + animFrame * Math.PI * 3;
    const dist = H * .08 * animFrame;
    const sx = penguinX + Math.cos(angle) * dist;
    const sy = slideY + Math.sin(angle) * dist;
    ctx.fillStyle = sparkleColors[i % sparkleColors.length];
    ctx.globalAlpha = Math.max(0, 1 - animFrame * .6);
    drawStar(ctx, sx, sy, 4, H * .012, H * .006);
    ctx.globalAlpha = 1;
  }

  // still draw partial igloo in background
  drawIgloo(ctx, iglooX, iglooBaseY, H, wrongCount);
}

function drawArcticLose(ctx, iglooX, iglooBaseY, W, H, groundY) {
  // draw complete igloo
  drawIgloo(ctx, iglooX, iglooBaseY, H, 6);

  // penguin waddles toward igloo then peeks from door
  const penguinStartX = W * .3;
  const doorX = iglooX + H * .22 * .25;

  if (animFrame < .5) {
    // waddle toward igloo
    const walkProgress = animFrame * 2;
    const px = penguinStartX + walkProgress * (doorX - penguinStartX);
    const waddle = Math.sin(walkProgress * Math.PI * 8) * 3;
    drawPenguin(ctx, px, groundY - H * .08 + waddle, H);
  } else {
    // peek from doorway
    const peekProgress = (animFrame - .5) * 2;
    const iglooH = H * .2;
    const iglooW = H * .22;
    const peekX = iglooX + iglooW * .25;
    const peekY = groundY - iglooH * .08;
    const sz = H * .03;

    // small penguin face in door
    ctx.fillStyle = '#1a1a2e';
    ctx.beginPath(); ctx.arc(peekX, peekY - sz * .5, sz * .8, 0, Math.PI * 2); ctx.fill();
    // white face
    ctx.fillStyle = '#f0f0f0';
    ctx.beginPath(); ctx.ellipse(peekX, peekY - sz * .35, sz * .5, sz * .4, 0, 0, Math.PI * 2); ctx.fill();
    // eyes - blink occasionally
    const blink = Math.sin(peekProgress * Math.PI * 4) > .9;
    ctx.fillStyle = '#0b0e2d';
    if (!blink) {
      ctx.beginPath(); ctx.arc(peekX - sz * .2, peekY - sz * .5, sz * .1, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(peekX + sz * .2, peekY - sz * .5, sz * .1, 0, Math.PI * 2); ctx.fill();
      // eye shine
      ctx.fillStyle = '#fff';
      ctx.beginPath(); ctx.arc(peekX - sz * .15, peekY - sz * .55, sz * .04, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(peekX + sz * .25, peekY - sz * .55, sz * .04, 0, Math.PI * 2); ctx.fill();
    } else {
      // closed eyes
      ctx.strokeStyle = '#0b0e2d'; ctx.lineWidth = 1.5;
      ctx.beginPath(); ctx.moveTo(peekX - sz * .3, peekY - sz * .5); ctx.lineTo(peekX - sz * .1, peekY - sz * .5); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(peekX + sz * .1, peekY - sz * .5); ctx.lineTo(peekX + sz * .3, peekY - sz * .5); ctx.stroke();
    }
    // beak
    ctx.fillStyle = '#ff9f43';
    ctx.beginPath();
    ctx.moveTo(peekX, peekY - sz * .25);
    ctx.lineTo(peekX - sz * .12, peekY - sz * .1);
    ctx.lineTo(peekX + sz * .12, peekY - sz * .1);
    ctx.closePath(); ctx.fill();
  }
}

// ========== RESIZE ==========
window.addEventListener('resize', ()=>{ if($('game-screen').classList.contains('active')) drawCanvas(); });

// ========== CELEBRATION ==========
function spawnCelebration(){
  const c = $('celebration'); c.innerHTML='';
  const colors=['#ffd166','#06d6a0','#ef476f','#a0c4ff','#f72585','#7209b7','#fff'];
  for(let i=0;i<50;i++){
    const p = document.createElement('div');
    p.className='particle';
    const sz = Math.random()*10+4;
    const tx = (Math.random()-.5)*window.innerWidth*.8;
    const ty = -(Math.random()*window.innerHeight*.6+100);
    const dur = Math.random()*1.2+.8;
    Object.assign(p.style,{
      width:sz+'px', height:sz+'px',
      left: Math.random()*100+'%', top: (60+Math.random()*30)+'%',
      background: colors[Math.floor(Math.random()*colors.length)],
      '--tx':tx+'px', '--ty':ty+'px', '--dur':dur+'s'
    });
    c.appendChild(p);
  }
  setTimeout(()=>c.innerHTML='', 2500);
}
</script>
</body>
</html>
